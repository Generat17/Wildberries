/*

4. Реализовать постоянную запись данных в канал (главный поток).
Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout.
Необходима возможность выбора количества воркеров при старте.

Программа должна завершаться по нажатию Ctrl+C.
Выбрать и обосновать способ завершения работы всех воркеров.

*/

package main

import (
	"context"
	"fmt"
	"math/rand"
	"os"
	"strconv"
	"time"
)

func main() {
	// Проверяем, что передан аргумент с количеством воркеров
	if len(os.Args) < 2 {
		fmt.Println("Укажите количество воркеров в качестве аргумента при запуске")
		fmt.Println("Например: go run main.go 4")
		return
	}

	// Преобразуем аргумент в число
	n, err := strconv.Atoi(os.Args[1])
	if err != nil {
		fmt.Println("Неверный формат аргумента")
		return
	}

	// Создаем канал для передачи данных
	ch := make(chan int)

	// Запускаем горутину, которая постоянно записывает данные в канал
	go func() {
		for {
			ch <- rand.Intn(100)    // Генерируем случайное число от 0 до 99 и записываем его в канал
			time.Sleep(time.Second) // Ждем одну секунду
		}
	}()

	// Создаем контекст с функцией отмены
	ctx, cancel := context.WithCancel(context.Background())

	// Запускаем n воркеров, которые читают данные из канала и выводят их в stdout
	for i := 0; i < n; i++ {
		go func(i int, ctx context.Context) {
			for {
				select {
				case <-ctx.Done(): // Если контекст был отменен, выходим из горутины
					return
				default: // Иначе продолжаем работать
					data := <-ch                                            // Читаем данные из канала
					fmt.Printf("Воркер %d получил данные: %d\n", i+1, data) // Выводим данные в stdout
				}
			}
		}(i, ctx)
	}

	// Ждем нажатия клавиши Enter для завершения программы
	fmt.Println("Нажмите Ctrl+C или Enter для выхода")
	fmt.Scanln()

	// Вызываем функцию отмены, чтобы остановить воркеры
	defer cancel()
}
